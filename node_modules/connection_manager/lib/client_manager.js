var util = require('util');
var events = require('events');

var client = require('./client');

var DEFAULT_TIMEOUT = 60 * 1000;
var DEFAULT_INTERVAL = 1000;

function client_manager(settings) {
  var self = this;

  self.options = settings || {};

  events.EventEmitter.call(this);

  self.debug = self.options.debug || false;
  self.list = {};
  self.timeout = self.options.timeout || DEFAULT_TIMEOUT;
  self.interval = self.options.interval || DEFAULT_INTERVAL;

  /**
    * Handles an incoming message from a client.
    * If the client is not managed by this client manager, it will be added.
    *
    * Emits 'client_joined'
    *
    * @param Buffer msg
    * @param object rinfo = {remote-address, remote-port}
    * @return void
    */
  self.handle_msg = function(msg, rinfo) {
    if (self.debug) {
      console.log('Client Manager: handling new message from '
        + rinfo.address + ':' + rinfo.port + ', '
        + 'Message length: ' + msg.length + ' bytes');
    }

    var id = self.create_id(rinfo.address, rinfo.port);

    if (!self.list[id]) {
      // new client!
      self.list[id] = self.create_client(id, rinfo);
      self.emit('client_joined', id);
    }

    // pass message to client
    self.list[id].recv(msg);
  };

  /**
    * Creates a new client, binds event listeners and returns the client
    * instance.
    *
    * Emits 'client_action' event on a client action with id and action.
    * Emits 'client_left' event when a client closes, passes client id.
    *
    * @param string id
    * @param object rinfo = {remote-address, remote-port}
    * @return client
    */
  self.create_client = function(id, rinfo) {
    if (self.debug) {
      console.log('Client Manager: adding new client: '
        + rinfo.address + ':' + rinfo.port);
    }

    var new_client = new client(rinfo.address, rinfo.port, self.options);

    new_client.on('action', function(action) {
      self.emit('client_action', id, action);
    });

    new_client.on('close', function() {
      // bye bye!
      self.emit('client_left', id);
      delete self.list[id];
    });

    return new_client;
  };

  /**
    * Removes a client from the connection list.
    *
    * @param string id of the client
    * @return void
    */
  self.remove = function(id) {
    if (self.debug) {
      console.log('Client Manager: removing client: '
        + self.list[id].addr + ':' + self.list[id].port);
    }

    self.list[id].close();
  };

  /**
    * Clears alls connections. Utilizes self.remove().
    *
    * @return void
    */
  self.remove_all = function() {
    for (id in self.list) {
      self.remove(id);
    }
  };

  /**
    * Garbage collection for timed-out connections.
    *
    * @return void
    */
  self.cleanup = function() {
    var cleanups = 0;

    for (id in self.list) {
      var client = self.list[id];
      var now = Date.now();
      if (client.activity + self.timeout < now) {
        if (self.debug) {
          console.log('Killing client ' + id + ', inactive for more than '
            + Number(self.timeout / 1000) + 's.');
        }

        self.remove(id);
        cleanups++;
      }
    }
  };

  /**
    * Create an ID from clients' host and port
    *
    * @param string raddr Remote address
    * @param int rport Remote port
    * @return string
    */
  self.create_id = function(raddr, rport) {
    return raddr.replace(/[^0-9]/g,'') + ':' + rport;
  };

  // Setup garbage collector
  setInterval(function() { return self.cleanup(); }, self.interval);

}

util.inherits(client_manager, events.EventEmitter);

exports = module.exports = client_manager;
